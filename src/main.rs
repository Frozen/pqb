//fn split<'a>(s: &'a str) -> Vec<&'a str> {
//
//    let x: Vec<_> = s.split("/").collect();
//    return vec![s, s]
//
//
//}

#[macro_use]
extern crate pqb_codegen;

#[macro_use]
extern crate log;

extern crate pqb;
//use pqb::{SelectQuery, AsMap, insert, update, DbModel};
use pqb::prelude::*;

extern crate postgres;
use postgres::{Connection, TlsMode};
use postgres::rows::{Row, Rows};
use postgres::types::ToSql;

#[derive(Model, Default, Debug)]
struct User {
    id: i32,
    nickname: String,
    avatar_url: Option<String>,
}

impl User {
    fn autogenerated() -> Vec<&'static str> {
        //        let mut x = HashSet::new();
        //        x.insert("id");
        //        x
        vec!["id"]
    }
}

#[derive(ModelList)]
struct UserList {
    rows: Vec<User>,
}

//impl User {
//    pub fn as_map(&self) -> std::collections::HashMap<&'static str, &ToSql> {
//
//        let mut map = std::collections::HashMap::new();
//        map.insert("id", &self.id as &ToSql);
//
//        return map;
//    }
//}

//
//fn main() {
//
//    println!("{:?}", MySuperStruct::fields());
//
//
//
//}

fn main() {
    User::select().filter("id = ?", &5);

    //    let conn = Connection::connect("postgres://roulette@localhost:5433", TlsMode::None).unwrap();
    //    conn.execute("CREATE TABLE person (
    //                    id              SERIAL PRIMARY KEY,
    //                    name            VARCHAR NOT NULL,
    //                    data            BYTEA
    //                  )", &[]).unwrap();
    //    let me = Person {
    //        id: 0,
    //        name: "Steven".to_string(),
    //        data: None,
    //    };
    //        conn.execute("INSERT INTO person (name, data) VALUES ($1, $2)",
    //                     &[&me.name, &me.data]).unwrap();

    let mut u = User::default();

    u.id = 5;
    u.nickname = "blabla".to_string();
    u.avatar_url = Some("http://ya.ru".to_string());

    //    println!("as_map = {:?}", u.as_map());

    //    User::insert(&u).query(&conn);

    "AAA".to_lowercase();

    //    insert(&conn, &User::name(), &u.as_map(), &User::autogenerated(), &User::fields()).unwrap();
    //    update(&conn, &u, &User::autogenerated()).unwrap();

    //    User::select().filter("id = ?", &5).query(&conn);

    //    let rs = conn.query("insert into commission(item_id) values($1), ($2) returning id, item_id", &[&1, &1]).unwrap();
    //
    //    println!("{:?}", rs);
    //
    //    for r in &rs {
    //        println!("{:?}", r);
    //        let id: i32 = r.get("id");
    //        let item_id: i32 = r.get("item_id");
    //        println!("{:?} {:?}", id, item_id);
    //    }

    //    inner(&conn).unwrap();
}

fn inner(conn: &Connection) -> postgres::Result<UserList> {
    //    let rows: UserList = conn.query("SELECT * FROM \"user\"", &[])?.iter().map(|e| e).collect();
    let rows: UserList = conn.query("SELECT * FROM \"user\"", &[])?.into();

    for row in &rows.rows {
        println!("Found person {}", row.nickname);
    }

    Ok(rows)
}

//pub impl #name {
//pub fn select() -> SelectQuery {
//SelectQuery::new_from_model(#name::model())
//}
//
//pub fn fields() -> #name_fields {
//#name_fields::default()
//}
//
//
//}
//
//impl Model for #name {
//fn model() -> ModelInstance {
//ModelInstance {
//name: #name
//}
//}
//}
